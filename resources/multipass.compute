#section common
#version 450 core

layout (std140, binding = 0) uniform fftSettings
{
  int passNum;
  bool vertical;
  bool readFromBuffer;
  float dummy;
};

#define SIZE 32
#define LOG_SIZE int(log2(SIZE))
#define NUM_CACHES 2
#define M_PI 3.141592653589793238

layout (rgba32f, binding = 0) uniform image2D image;

#section type(compute) name(fftShift)

void main()
{
  ivec2 start = ivec2(gl_GlobalInvocationID.xy);
  ivec2 end = (start + SIZE/2) % SIZE;

  vec4 current = imageLoad(image, start);
  vec4 other = imageLoad(image, end);
  
  imageStore(image, start, other);
  imageStore(image, end, current);
}

#section type(compute) name(imageReversal)

layout (local_size_x = SIZE) in;

uint reverseBits(uint num, uint numBits)
{
  return (bitfieldReverse(num) >> (32 - numBits));
}

// direction-wise bit reversal of image
void main()
{
  ivec2 thread = ivec2(gl_GlobalInvocationID.xy);

  // determine the slot to read from based on direction
  ivec2 revCoord;
  if (!vertical)
    revCoord = ivec2(reverseBits(thread.x, LOG_SIZE), thread.y);
  else
    revCoord = ivec2(thread.y, reverseBits(thread.x, LOG_SIZE));

  // fetch value and wait for threadgroup to finish reading
  vec4 revValue = imageLoad(image, revCoord);
  barrier();

  // write our value back to the image
  imageStore(image, thread, revValue);
}

#section type(compute) name(fft)

layout (local_size_x = SIZE/2) in;

void main()
{
  uvec2 id = uvec2(gl_GlobalInvocationID.xy);
  uint thread = id.x;

  // calculate our new even and odd indices
  // 1) use one thread per set of even and odd indices
  // 2) each dft requires half its size worth of threads => dft # is (thread div halfSize)
  // 3) even index = dftNum * dftSize + (thread mod halfSize)
  // 4) odd index = evenIndex + halfSize
  uint halfSize = 1u << passNum;
  uint fullSize = halfSize << 1;
  int dftNum = int(thread) / int(halfSize);
  int dftElement = int(thread) % int(halfSize);
  int evenIndex = dftNum * int(fullSize) + dftElement;
  int oddIndex = evenIndex + int(halfSize);

  // obtain position in image based on direction
  ivec2 evenPos = vertical ? ivec2(id.y, evenIndex) : ivec2(evenIndex, id.y);
  ivec2 oddPos = vertical ? ivec2(id.y, oddIndex) : ivec2(oddIndex, id.y);

  // retrieve our values and twiddle the odd factor
  dvec2 even = imageLoad(image, evenPos).xy;
  dvec2 odd = imageLoad(image, oddPos).xy;

  // compute the twiddle factor for combining two dfts
  float twiddleAngle = 2.0 * M_PI * dftElement / fullSize; // making this positive causes iFFT
  dvec2 twiddle = dvec2(cos(twiddleAngle), sin(twiddleAngle));

  odd = vec2(odd.x * twiddle.x - odd.y * twiddle.y,
             odd.x * twiddle.y + odd.y * twiddle.x);
                
  // store them back into our texture
  imageStore(image, evenPos, 0.5 * vec4(even + odd, 0.0, 2.0));
  imageStore(image, oddPos, 0.5 * vec4(even - odd, 0.0, 2.0));
}