#section common
#version 450 core

#define SIZE 256
#define LOG_SIZE int(log2(SIZE))
#define M_PI 3.14159265358

layout(rgba32f, binding = 0) uniform readonly image2D imgInput;
layout(rgba32f, binding = 1) uniform writeonly image2D imgOutput0;
layout(rgba32f, binding = 2) uniform writeonly image2D imgOutput1;

layout(std140, binding = 0) uniform spectrumSettings
{
  float time;           // The time in seconds since the program began.
  float planeSize;      // The size of the plane in meters that this plane is simulating
  float gravity;        // The acceleration due to gravity.
  float scale;          // The global heightmap scalar.
  vec2 windVelocity;    // The velocity of the wind used to calculate the direction
  float wavelengthMin;  // The minimum wavelength that is allowed
  float wavelengthMax;  // The maximum wavelength that is allowed
  float displacement;   // The scalar used in displacing the vertices.
  int boundWavelength;  // Whether or not we bound the wavelength (1 = bound, 0 = unbound)
  float dummy1, dummy2; // Ensure that we are 16-byte aligned
};

vec2 threadToWaveNumber(vec2 thread)
{
  vec2 frequency = thread - SIZE / 2;
  return 2.0 * M_PI * frequency / planeSize;
}

vec2 complexMultiply(vec2 lhs, vec2 rhs)
{
  return vec2(lhs.x * rhs.x - lhs.y * rhs.y, lhs.x * rhs.y + lhs.y * rhs.x);
}

float dispersion(vec2 waveNumber, float gravity)
{
  return sqrt(gravity * length(waveNumber));
}

#section type(compute) name(generateSpectrum)

float phillips(vec2 waveNumber, vec2 windVelocity, float gravity)
{
  float waveNumberLength = length(waveNumber);
  if (waveNumberLength == 0.0)
    return 0.0;

  float waveNumberLength2 = waveNumberLength * waveNumberLength;
  float waveNumberLength4 = waveNumberLength2 * waveNumberLength2;
  vec2 waveNumberDir = normalize(waveNumber);

  float windSpeed = length(windVelocity);
  vec2 windDir = normalize(windVelocity);

  float waveDotWind = dot(waveNumberDir, windDir);
  float waveDotWind2 = waveDotWind * waveDotWind;

  float L = windSpeed * windSpeed / gravity;
  float L2 = L * L;

  float damping = 0.005;
  float l2 = L2 * damping * damping;

  return exp(-1.0 / (waveNumberLength2 * L2)) / waveNumberLength4 * waveDotWind2 *
         exp(-waveNumberLength2 * l2);
}

void main()
{
  vec2 thread = vec2(gl_GlobalInvocationID.xy);
  vec2 waveNumber = threadToWaveNumber(thread);

  float wavelength = length(2 * M_PI / waveNumber);
  float inRange = max(1.0 - float(boundWavelength),
                      step(wavelengthMin, wavelength) * step(wavelength, wavelengthMax));

  // Fetch a random Gaussian value to model probability of wave existing
  vec2 currentValue = imageLoad(imgInput, ivec2(thread)).xy;

  // Calculate and store the amplitude using the phillips spectrum
  float globalScale = 0.0025;
  vec2 amp = inRange * globalScale * scale * currentValue *
             sqrt(phillips(waveNumber, windVelocity, gravity));
  imageStore(imgOutput0, ivec2(thread), vec4(amp, 0.0, 1.0));
}

#section type(compute) name(prepareFFT)

// Since we are only working with a real heightmap, we can make an important optimization.
// Ideally, our FFT only produces real data. To do this, for every wave, we send a complex
// conjugate wave in the opposite direction. At any given point or time, these two waves will have
// opposite complex magnitudes, and thus will sum to be only a real number (twice the original).
// The advantage is that due the linearity of the FFT we can simply add another set of frequencies
// with this property all multiplied by i to only output complex values. Thus, we can fit four
// FFTs in a single image, which we take to have two complex values.
void main()
{
  // Get the thread that we are working with, and convert that to a usable wave number.
  vec2 thread = vec2(gl_GlobalInvocationID.xy);
  vec2 waveNumber = threadToWaveNumber(thread);
  vec2 waveDir = waveNumber == vec2(0.0) ? waveNumber : normalize(waveNumber);

  // Get the amplitude of our current wave, and propogate it through space at the rate determined by
  // the dispersion relation.
  vec2 amplitude = imageLoad(imgInput, ivec2(thread)).xy;
  float phase = dispersion(waveNumber, gravity) * time;

  // Propogate using eulers formula.
  vec2 wave = vec2(cos(phase), sin(phase));
  amplitude = complexMultiply(amplitude, wave);

  // The opposite wave will be sending out its conjugate wave this direction.
  vec2 oppAmplitude = imageLoad(imgInput, ivec2(SIZE - thread)).xy;
  oppAmplitude = complexMultiply(oppAmplitude, wave);

  // Make this a conjugate wave.
  oppAmplitude.y *= -1.0;

  // The total spatial amplitude is the sum of the amplitude and the opposite amplitude.
  vec2 heightAmp = amplitude + oppAmplitude;
  vec2 heightAmpTimesi = vec2(-heightAmp.y, heightAmp.x);

  // Next, we need to calculate the slope and displacement map, and certain respective partial
  // derivatives which are important for lighting. First, we take the partials of the heightmap
  // w.r.t x and z so that we can calculate normals. Thankfully, all we have to do it take each wave
  // and multiply by i and the component of the wave number in each direction.
  vec2 dhdx = waveNumber.x * vec2(-heightAmp.y, heightAmp.x);
  vec2 dhdz = waveNumber.y * vec2(-heightAmp.y, heightAmp.x);

  // The next few are the displacement, which are difficult to calculate. We need the displacement
  // vectors for both the x and z coordinates, as well as the partial derivatives of this w.r.t x
  // and z for calculating the jacobian of the matrix (detect local inversion to spawn foam). The
  // displacement is basically in the same direction as the derivative, so that we push the steep
  // parts toward their peaks.
  vec2 disX = waveDir.x * heightAmpTimesi;
  vec2 disZ = waveDir.y * heightAmpTimesi;

  // We use algebra for these, and it happens to work out so that we just multiply the amplitudes by
  // the directions with one of them being normalized.
  vec2 dDXdx = waveNumber.x * waveDir.x * heightAmp;
  vec2 dDZdz = waveNumber.y * waveDir.y * heightAmp;
  vec2 dDXdz = waveNumber.y * waveDir.x * heightAmp;

  // Now, we have to combine our FFTs into a the image. We multiply the second FFT by i to pack.
  vec4 output0 = vec4(heightAmp.x - dhdx.y, heightAmp.y + dhdx.x, dhdz.x - disX.y, dhdz.y + disX.x);
  vec4 output1 = vec4(disZ.x - dDXdx.y, disZ.y + dDXdx.x, dDZdz.x - dDXdz.y, dDZdz.y + dDXdz.x);
  imageStore(imgOutput0, ivec2(thread), output0);
  imageStore(imgOutput1, ivec2(thread), output1);
}