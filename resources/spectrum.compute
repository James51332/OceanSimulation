#section common
#version 450 core

#define SIZE 1024
#define LOG_SIZE int(log2(SIZE))
#define M_PI 3.1415926535897932384

layout (rgba32f, binding = 0) uniform image2D image0;
layout (rgba32f, binding = 1) uniform image2D image1;

layout (std140, binding = 0) uniform spectrumSettings
{
  float time;
  float planeSize;
  float gravity;
  float scale;
  vec2 windVelocity;
  vec2 dummy;
};

vec2 threadToWaveNumber(vec2 thread)
{
  vec2 frequency = thread - SIZE/2;
  return 2.0 * M_PI * frequency / planeSize;
}

#section type(compute) name(generateSpectrum)

float phillips(vec2 waveNumber, vec2 windVelocity, float gravity)
{
  float waveNumberLength = length(waveNumber);
  if (waveNumberLength == 0.0)
    return 0.0;

  float waveNumberLength2 = waveNumberLength * waveNumberLength;
  float waveNumberLength4 = waveNumberLength2 * waveNumberLength2;
  vec2 waveNumberDir = normalize(waveNumber);
  
  float windSpeed = length(windVelocity);
  vec2 windDir = normalize(windVelocity);
  
  float waveDotWind = dot(waveNumberDir, windDir);
  float waveDotWind2 = waveDotWind * waveDotWind;
  
  float L = windSpeed * windSpeed / gravity;
  float L2 = L * L;

  float damping = 0.001;
	float l2 = L2 * damping * damping;
  
  return exp(-1.0 / (waveNumberLength2 * L2)) / waveNumberLength4 * waveDotWind2 * exp(-waveNumberLength2 * l2);
}

float dispersion(vec2 waveNumber, float gravity)
{
  return sqrt(gravity * length(waveNumber));
}

void main()
{
  vec2 thread = vec2(gl_GlobalInvocationID.xy);
  vec2 waveNumber = threadToWaveNumber(thread);

  // Fetch a random Gaussian value to model probability of wave existing
  vec2 currentValue = imageLoad(image1, ivec2(thread)).xy;

  // Shift our wave through space based on the current time
  float phase = time * dispersion(waveNumber, gravity);
  vec2 rotate = vec2(cos(phase), sin(phase));
  currentValue = vec2(currentValue.x * rotate.x - currentValue.y * rotate.y,
                      currentValue.x * rotate.y + currentValue.y * rotate.x);
  
  // Calculate and store the amplitude using the phillips spectrum
  vec2 amp = scale * currentValue * sqrt(phillips(waveNumber, windVelocity, gravity));
  imageStore(image0, ivec2(thread), vec4(amp, 0.0, 1.0));
}

#section type(compute) name(prepareNormalMap)

layout (rgba32f, binding = 2) uniform image2D spectrum;

void main()
{
  vec2 thread = vec2(gl_GlobalInvocationID.xy);
  vec2 waveNumber = threadToWaveNumber(thread);

  // Determine this waves contribution to slope of final image
  vec2 currentAmp = imageLoad(spectrum, ivec2(thread)).xy;
  vec2 xDerivative = waveNumber.x * vec2(-currentAmp.y, currentAmp.x);
  vec2 zDerivative = waveNumber.y * vec2(-currentAmp.y, currentAmp.x);

  imageStore(image0, ivec2(thread), vec4(xDerivative, 0.0, 1.0));
  imageStore(image1, ivec2(thread), vec4(zDerivative, 0.0, 1.0));
}

#section type(compute) name(combineNormalMap)

void main()
{
  ivec2 thread = ivec2(gl_GlobalInvocationID.xy);

  // Get the gradient in each direction and construct binormal and tangent vectors
  float xDerivative = imageLoad(image0, thread).x;
  vec3 binormal = vec3(1.0, xDerivative, 0.0);
  
  float zDerivative = imageLoad(image1, thread).x;
  vec3 tangent = vec3(0.0, zDerivative, 1.0);
  
  // Obtain normal vector orthogonal to both via cross product
  vec3 normal = normalize(cross(tangent, binormal));
  imageStore(image0, thread, vec4(normal, 1.0));
}

#section type(compute) name(prepareDisplacementMap)

layout (rgba32f, binding = 2) uniform image2D spectrum;

void main()
{
  vec2 thread = vec2(gl_GlobalInvocationID.xy);
  vec2 waveNumber = threadToWaveNumber(thread);
  vec2 waveDir = normalize(waveNumber);

  // Displacement vector = -i * k/|k| * exp(i * dot(k,x));
  vec2 currentAmp = imageLoad(spectrum, ivec2(thread)).xy;
  vec2 xDisplacementSignal = waveDir.x * vec2(currentAmp.y, -currentAmp.x);
  vec2 zDisplacementSignal = waveDir.x * vec2(currentAmp.y, -currentAmp.x);

  imageStore(image0, ivec2(thread), vec4(xDisplacementSignal, 0.0, 1.0));
  imageStore(image1, ivec2(thread), vec4(zDisplacementSignal, 0.0, 1.0));
}

#section type(compute) name(combineDisplacementMap)

void main()
{
  vec2 thread = vec2(gl_GlobalInvocationID.xy);
  vec2 xDisplacement = imageLoad(image0, ivec2(thread)).xy;
  vec2 zDisplacement = imageLoad(image1, ivec2(thread)).xy;
  imageStore(image0, ivec2(thread), vec4(xDisplacement, zDisplacement));
}